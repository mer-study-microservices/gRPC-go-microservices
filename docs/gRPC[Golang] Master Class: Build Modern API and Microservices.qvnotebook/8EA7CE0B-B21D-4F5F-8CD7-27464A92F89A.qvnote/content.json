{
  "title": "2 - [Theory] gRPC Internals Deep Dive ",
  "cells": [
    {
      "type": "text",
      "data": "<h3>Protocol Buffers &amp; Language Interoperability&nbsp;</h3>"
    },
    {
      "type": "text",
      "data": "<b>Protocol Buffers role in gRPC</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>Protocol Buffers is used to define the:</li><ul><li>Messages (data, Reauest and Response)</li><li>Service (Service name and RPC endpoints)</li></ul><li>We then generate code from it!</li></ul>"
    },
    {
      "type": "text",
      "data": "<b>Efficiency of Protocol Buffers over JSON</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>gRPC uses Protocol Buffers for communications.&nbsp;</li><li>Let’s measure the payload size vs JSON:</li></ul>"
    },
    {
      "type": "text",
      "data": "<img src=\"quiver-image-url/F8ABDF7B7A8F9F21A204AA7AE8D8BF92.png\" alt=\"Screen Shot 2019-02-05 at 18.13.19.png\" width=\"691\" height=\"188\">"
    },
    {
      "type": "text",
      "data": "<ul><li><b>We save in Network Bandwidth</b></li></ul>"
    },
    {
      "type": "text",
      "data": "<ul><li>Parsing JSON is actually CPU intensive (because the format is human readable)</li><li>Parsing Protocol Buffers (binary format) is less CPU intensive because it’s closer to how a machine represents data&nbsp;</li><li>By using gRPC, the use of Protocol Buffers means <font color=\"#0096ff\">faster</font> and more <font color=\"#0096ff\">efficient</font> communication, friendly with mobile devices that have a slower CPU&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<b>Quick tour on grpc.io</b>"
    },
    {
      "type": "text",
      "data": "https://grpc.io/"
    },
    {
      "type": "text",
      "data": "<ul><li>And many other languages are unofficially supported! (Swift, etc…)<br></li></ul>"
    },
    {
      "type": "text",
      "data": "<b>gRPC Languages</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>gRPC will have these main implementations:</li><ul><li>GRPC-JAVA: Pure implementation of gRPC in Java</li><li>GRPC-Go: Pure implementation of gRPC in Go&nbsp;</li><li>GRPC-C: Pure implmenetation of gRPC in C</li><ul><li>gRPC C++</li><li>gRPC Python</li><li>gRPC Ruby</li><li>gRPC Objective C</li><li>gRPC PHP</li><li>gRPC C#</li></ul></ul><li>Other languages implement gRPC natively or rely on C implementation&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<b>gRPC can be used by any language&nbsp;</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>Because the code can be generated by any language, it makes it super simple to create micro-service in any language that interact with each other&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<img src=\"quiver-image-url/1DF848E5484D66F67718667700846C57.png\" alt=\"Screen Shot 2019-02-05 at 18.32.58.png\" width=\"667\" height=\"236\"><br>"
    },
    {
      "type": "text",
      "data": "<b>Summary: Why Protocol Buffers?</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>Easy to write message definition&nbsp;</li><li>The definition of the API is independent from the implementation&nbsp;</li><li>A <u>huge amount of code</u> can be generated, in any language, from a simple .proto file&nbsp;</li><li>The payload is binary, therefore very efficient to send / receive on a network and serialize / de-serialize on a CPU&nbsp;</li><li>Protocol Buffers defines rules to make an API evolve without breaking existing clients, which is helpful for microservices&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<h3>HTTP/2</h3>"
    },
    {
      "type": "text",
      "data": "<b>What’s HTTP/2?</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>gRPC leverages HTTP/2 as a backbone for communications&nbsp;</li><li>Demo: https://imagekit.io/demo/http2-vs-http1</li><li>HTTP/2 is the newer standard for inernet communications that address common pitfall of HTTP/1.1 on modern web pages&nbsp;</li><li>Before we go into HTTP/2, let’s look at some HTTP/1.1 request&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<b>How HTTP /1.1 works</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>HTTP 1.1 was released in 1997. It has worked great for many years!</li><li>HTTP 1.1 opens a new TCP connection to a server at each request</li><li>It does not compress headers (which are plaintext)</li><li>It only works with Request/Reponse mechanism (no server push)</li><li>HTTP was originally composed of two commands:</li><ul><li>GET: to ask for content&nbsp;</li><li>POST: to send content&nbsp;</li></ul><li>Nowadays, a web page loads 80 assets on average&nbsp;</li><li>Headers are sent at every request and are PLAINTEXT (heavy size)</li><li>Each request opens a TCP connection&nbsp;</li><li>These inefficiencies add latency and increase network packet size&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<img src=\"quiver-image-url/7DF1A6DDE0DA52F57EB449E389713AB0.png\" alt=\"Screen Shot 2019-02-05 at 19.05.02.png\" width=\"639\" height=\"211\">"
    },
    {
      "type": "text",
      "data": "<b>How HTTP/2 works</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>HTTP 2 was released in 2015. It has been battled tested for many years! (and was before that tested by Google under the name SPDY)</li><li>HTTP 2 supports multiplexing&nbsp;</li><ul><li>The client &amp; server can push messages in parallel over the same TCP connection&nbsp;</li><li>This greatly reduces latency&nbsp;</li></ul><li>HTTP 2 supports server push&nbsp;</li><ul><li>Servers can push streams (multiple messages) for one request from the client&nbsp;</li><li>This saves round trips (latency)</li></ul><li>HTTP2 supports header compression&nbsp;</li><ul><li>Headers (text based) can now be compressed&nbsp;</li><li>These have much less impact on the packet size&nbsp;</li><li>(remember the average http request may have over 20 headers, due to cookies, content cache, and application headers)</li></ul><li>HTTP/2 is binary&nbsp;</li><ul><li>While HTTP/1 text makes it easy for debugging, it’s not efficient over the network&nbsp;</li><li>(Protocol buffers is a binary protocol and makes it a great match for HTTP2)</li></ul><li>HTTP/2 is secure (SSL is not required but recommended by default)</li></ul>"
    },
    {
      "type": "text",
      "data": "<b>How HTTP/2 works</b>"
    },
    {
      "type": "text",
      "data": "<img src=\"quiver-image-url/05A4262CD5E12A48D6AD64DE51301E0C.png\" alt=\"Screen Shot 2019-02-06 at 14.45.42.png\" width=\"651\" height=\"272\">"
    },
    {
      "type": "text",
      "data": "<b>HTTP/2: Bottom Line</b>"
    },
    {
      "type": "text",
      "data": "<ul><li>Less chatter&nbsp;</li><li>More efficient protocol (less bandwith)</li><li>Reduced Latency&nbsp;</li><li>Increased Security&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<ul><li><b>And you get all these improvements out of the box by using the gRPC framework!</b><br></li></ul>"
    },
    {
      "type": "text",
      "data": "<h3>4 Types of gRPC APIs</h3>"
    },
    {
      "type": "text",
      "data": "<img src=\"quiver-image-url/F9EDCDB395DF28111C80F9B55B7232F3.png\" alt=\"Screen Shot 2019-02-06 at 14.49.38.png\" width=\"674\" height=\"320\">"
    },
    {
      "type": "text",
      "data": "<ul><li>Unary is what a traditional API looks like (HTTP REST)</li><li>HTTP/2 as we’ve seen, enables APIs to now have streaming capabilities&nbsp;</li><li>The server and the client can push multiple messages as part of one request!</li><li>In gRPC it’s very easy to define these APIs as we’ll see</li></ul>"
    },
    {
      "type": "text",
      "data": "<img src=\"quiver-image-url/BF7CF9479D2F5B8D4511F16BF0C8AA93.png\" alt=\"Screen Shot 2019-02-06 at 14.51.34.png\" width=\"715\" height=\"261\"><br>"
    },
    {
      "type": "text",
      "data": "<h3>Scalability in gRPC</h3>"
    },
    {
      "type": "text",
      "data": "<ul><li>gRPC Servers are asynchronous by default&nbsp;</li><li>This means they do not block threads on request&nbsp;</li><li>Therefore each gRPC server can serve millions of requests in parallel&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<ul><li>gRPC Clients can be asynchronous or synchronous (blocking)</li><li>The client decides which model works best for the performance needs&nbsp;</li><li>gRPC Clients can perform client side load balancing&nbsp;</li></ul>"
    },
    {
      "type": "text",
      "data": "<ul><li>As a proof of scalability: <u>Google has 10 BILIION gRPC requests being made per second internally</u></li></ul>"
    },
    {
      "type": "text",
      "data": "<h3>Security in gRPC</h3>"
    },
    {
      "type": "text",
      "data": "<ul><li>By default gRPC strongly advocates for you to use SSL (encryption over the wire) in your API&nbsp;</li><li>This means that gRPC has security as a first class citizen&nbsp;</li><li>Each language will provide an API to load gRPC with the required certificates and provide encryption capability out of the box</li><li>Additionally using Interceptors, we can also provide authentication (we’ll learn about Interceptors in the advanced section)</li></ul>"
    },
    {
      "type": "text",
      "data": "<h3>gRPC vs REST</h3>"
    },
    {
      "type": "text",
      "data": "<b>REST API example&nbsp;</b>"
    },
    {
      "type": "text",
      "data": "<img src=\"quiver-image-url/1024B9023A7F8EBD3456CF47D65287F6.png\" alt=\"Screen Shot 2019-02-06 at 15.08.22.png\" width=\"340\" height=\"276\">"
    },
    {
      "type": "text",
      "data": "<b>gRPC vs REST</b>"
    },
    {
      "type": "markdown",
      "data": "|GRPC|REST|\n|-|-|\n|Protocol Buffers - smaller, faster|JSON - text based, slower, bigger|\n|HTTP/2 (lower latency) - from 2015|HTTP1.1 (higher latency) - from 1997|\n|Bidirectional & Async|Client => Server requests only|\n|Stream Support|Request/Response support only|\n|API Oriented - \"What\" (no constraints - free design)|CRUD Oriented (Create - Retrieve - Update - Delete / POST GET PUT DELETE)|\n|Code Generation through Protocl Buffers i any language - 1st class citizen|Code generation through OpenAPI/Swagger (add-on) - 2nd class citizen|\n|RPC Based - gRPC does the plumbing for us|HTTP verbs based - we have to write the plumbing or use a 3rd party library|"
    },
    {
      "type": "text",
      "data": "<ul><li>https://husobee.github.io/golang/rest/grpc/2016/05/28/golang-rest-v-grpc.html: Finds that gRPC is <font color=\"#0096ff\">25 times more performant</font> than REST API (as defined as time to have the response for an API)</li></ul>"
    },
    {
      "type": "text",
      "data": "<h3><b>Section Summary - Why use gRPC</b></h3>"
    },
    {
      "type": "text",
      "data": "<ul><li>Easy code definition in over 11 languages&nbsp;</li><li>Uses a modern, low latency HTTP/2 trasnport mechanism&nbsp;</li><li>SSL Security is built in&nbsp;</li><li>Support for streaming APIs for maximum performance&nbsp;</li><li>gRPC is API oriented, instead of Resource Oriented like REST</li></ul>"
    },
    {
      "type": "text",
      "data": "<br>"
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}